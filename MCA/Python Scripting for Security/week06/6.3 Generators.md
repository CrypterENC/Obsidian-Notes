Generators are special functions that give you values one by one. They use 'yield' to send a value and remember where they stopped, so they can continue later.

## Creating Generators

To make a generator, write a function with 'yield' instead of 'return'.

```python
def generate_numbers(limit):
    for num in range(1, limit + 1):
        yield num

for value in generate_numbers(5):
    print(value)  # 1 2 3 4 5
    
def gener_number(limit):
    num = 1
    while num <= limit:
        yield num
        num += 1

for value in gener_number(5):
    print(value)
```

## Yield vs Return

- 'yield': Stops the function for a bit, gives a value, and remembers everything.

- 'return': Stops the function forever and gives one final value.

```python
def calculate_total():
    values = [1, 2, 3]
    result = sum(values)
    return result

print(calculate_total())  # 6
```

## Generator Expressions

Generator expressions are like quick ways to make generators, using parentheses instead of brackets, and they save memory.

```python
squares = (num ** 2 for num in range(1, 6))
for square in squares:
    print(square)  # 1 4 9 16 25
```

## Applications

- Handling big amounts of data without using too much memory.
- Making endless lists like numbers in the Fibonacci sequence.

## More Examples

### Fibonacci Generator

```python
def fibonacci(limit):
    a, b = 0, 1
    count = 0
    while count < limit:
        yield a
        a, b = b, a + b
        count += 1

for num in fibonacci(10):
    print(num)  # 0 1 1 2 3 5 8 13 21 34
```

### Even Numbers Generator

```python
def even_numbers(n):
    for i in range(n):
        if i % 2 == 0:
            yield i

for even in even_numbers(10):
    print(even)  # 0 2 4 6 8
```

## Conclusion

Generators are memory-efficient for large data or sequences.