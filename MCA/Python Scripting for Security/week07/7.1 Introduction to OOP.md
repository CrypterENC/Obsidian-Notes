
OOP (Object-Oriented Programming) structures code using classes and objects. It bundles properties and behaviors for modularity, reusability, and scalability.

## Main Concepts

### Classes and Objects
- Class: Blueprint for objects.
- Object: Instance of a class.

Example:
```python
# Define a class named Employer to represent an employer entity
class Employer:
    # Constructor method to initialize the object
    # Takes name and industry as parameters and stores them as attributes
    def __init__(self, name, industry):  # Constructor: initializes object
        self.name = name  # Attribute to store the employer's name
        self.industry = industry  # Attribute to store the employer's industry

    # Method to display the employer's information
    # Prints a formatted string using the attributes
    def display_info(self):  # Method
        print(f"Employer: {self.name} - {self.industry}")

# Create an instance of the Employer class with specific values
employer_one = Employer("Tpoint Tech", "Education")

# Call the display_info method on the instance to print the information
employer_one.display_info()  # Output: Employer: Tpoint Tech - Education
```

### Encapsulation
Bundles data and methods, restricts direct access (data hiding).

Example:
```python
# Define a class named Employer to represent an employer entity
class Employer:
    # Constructor method to initialize the object
    # Takes employee_count as a parameter and stores it as a private attribute
    def __init__(self, employee_count):
        self.__employee_count = employee_count  # Private attribute (indicated by double underscores) to store the number of employees, not directly accessible from outside the class

    # Method to get the employee count
    # Returns the value of the private attribute __employee_count
    def get_employee_count(self):
        return self.__employee_count

# Create an instance of the Employer class with 1500 employees
employer_one = Employer(1500)

# Print the employee count by calling the get_employee_count method
print("Employees:", employer_one.get_employee_count())  # Output: Employees: 1500
```

### Inheritance
Allows child classes to reuse parent class properties.

Example:
```python
# Define a base class named Vertebrate to represent vertebrates
class Vertebrate:
    # Constructor to initialize the vertebrate with a name
    def __init__(self, name):
        self.name = name  # Attribute to store the name

    # Method to simulate movement
    def move(self):
        print(f"{self.name} moves.")

# Define a subclass Mammal that inherits from Vertebrate
class Mammal(Vertebrate):
    # Method specific to mammals for nursing
    def nurse(self):
        print(f"{self.name} nurses.")

# Create an instance of Mammal, which inherits from Vertebrate
dog = Mammal("Dog")

# Call the inherited move method
dog.move()  # Output: Dog moves.

# Call the specific nurse method
dog.nurse()  # Output: Dog nurses.
```

### Abstraction
Hides internal details, shows only necessary functionality.

Example:
```python
# Import ABC (Abstract Base Class) and abstractmethod from the abc module for abstraction
from abc import ABC, abstractmethod

# Define an abstract base class Shape that cannot be instantiated directly
class Shape(ABC):
    # Declare an abstract method that must be implemented by subclasses
    @abstractmethod
    def calc_area(self):
        pass  # No implementation here, subclasses must provide it

# Define a concrete subclass Circle that inherits from Shape
class Circle(Shape):
    # Constructor to initialize the circle with a radius
    def __init__(self, radius):
        self.radius = radius  # Attribute to store the radius

    # Implement the abstract method to calculate the area of the circle
    def calc_area(self):
        return 3.14 * self.radius ** 2  # Formula for circle area

# Create an instance of Circle
circle = Circle(5)

# Call the calc_area method and print the result
print("Area:", circle.calc_area())  # Output: Area: 78.5
```

### Polymorphism
Methods with same name but different behavior.

Example:
```python
# Define a base class Vertebrate
class Vertebrate:
    # Method to move, with a generic implementation
    def move(self):
        print("Moves generically.")

# Define a subclass Mammal that inherits from Vertebrate
class Mammal(Vertebrate):
    # Override the move method to provide specific behavior for mammals
    def move(self):  # Override
        print("Walks.")

# Create a list of different animal instances
animals = [Vertebrate(), Mammal()]

# Loop through the list and call the move method on each
# Demonstrates polymorphism: same method name, different behavior based on class
for animal in animals:
    animal.move()
# Output:
# Moves generically.
# Walks.
```

## Class Basics
Theory: Classes are blueprints for creating objects. They define properties and behaviors.

Syntax:
```python
class ClassName:
    # code
```

Code:
```python
# Define a class named Car (this is a simple class with no attributes or methods yet)
class Car:  # Define class
    pass  # Placeholder, no code inside

# Create an instance (object) of the Car class
my_car = Car()  # Create object

# Print the type of the object, which shows it's an instance of the Car class
print(type(my_car))  # Output: <class '__main__.Car'>
```
Explanation: `Car` is a class. `my_car` is an instance (object).

## __init__ and Attributes
Theory: `__init__` is a special method (constructor) called when creating an object. It initializes **attributes** (variables).

Syntax:
```python
def __init__(self, param):
    self.attribute = param
```

Code:
```python
# Define a class named Car
class Car:
    # Constructor method to initialize the object with a brand
    def __init__(self, brand):  # Constructor
        self.brand = brand  # Attribute to store the car's brand

# Create an instance of Car with a specific brand
my_car = Car("Toyota")

# Access and print the brand attribute of the instance
print(my_car.brand)  # Output: Toyota
```
Explanation: `__init__` sets up the object with attributes.

## Class Methods
Theory: Methods are functions inside a class that operate on objects. They use `self` to access attributes.

Syntax:
```python
def method_name(self):
    # code
```

Code:
```python
# Define a class named Car
class Car:
    # Constructor to initialize the car with a brand
    def __init__(self, brand):
        self.brand = brand

    # Define a method named drive that uses the brand attribute
    def drive(self):  # Method
        return f"{self.brand} is driving."

# Create an instance of Car
my_car = Car("Toyota")

# Call the drive method on the instance and print the result
print(my_car.drive())  # Output: Toyota is driving.
```
Explanation: `drive` is a method that uses `self.brand` to return a message.

## Dunder Methods
Theory: Dunder (double underscore) methods are special methods like `__init__`, `__str__`, `__add__` for built-in operations.

Syntax: `def __method_name__(self):`

Code:
```python
# Define a class named Car
class Car:
    # Constructor to initialize the car with a brand
    def __init__(self, brand):
        self.brand = brand

    # Define a dunder method __str__ to provide a string representation of the object
    def __str__(self):  # String representation
        return f"Car: {self.brand}"

# Create an instance of Car
my_car = Car("Toyota")

# Print the object, which calls __str__ to get the string representation
print(my_car)  # Output: Car: Toyota
```
Explanation: `__str__` defines how the object is printed as a string.

## Advantages
- Easier maintenance and scalability.
- Data hiding.
- Models real-world entities.

Conclusion: OOP organizes code, promotes reusability, and improves maintainability. 