# üìÅ Files in Python

## üîì Opening Files
- Use `open(file, mode)` to open a file.
- **Common Modes:**

| Mode | Description | Use Case |
|------|-------------|----------|
| `'r'` | Read (default) | Reading text files |
| `'w'` | Write (overwrites) | Creating/writing new files |
| `'a'` | Append | Adding to existing files |
| `'b'` | Binary | Reading/writing binary data (e.g., images) |
| `'+'` | Read/Write | Updating files |
| `'rb'` | Read Binary | Reading binary files |
| `'wb'` | Write Binary | Writing binary files |

## üìñ Reading Files
```python
with open('file.txt', 'r') as f:
    content = f.read()          # Read entire file as string
    lines = f.readlines()       # Read all lines as list
    line = f.readline()         # Read one line
    # Iterate over lines
    for line in f:
        print(line.strip())
```

## ‚úèÔ∏è Writing Files
```python
with open('file.txt', 'w') as f:
    f.write('Hello World!\n')                  # Write string
    f.writelines(['Line 1\n', 'Line 2\n'])      # Write list of strings
```

## üîÑ Using `with` Statement
- **Automatically closes the file** after the block.
- **Preferred** over manual `f.open()` and `f.close()`.
- Prevents resource leaks.

## üõ†Ô∏è File Object Methods
- `f.close()`: Manually close the file.
- `f.tell()`: Get current file position (bytes).
- `f.seek(pos)`: Move to a specific position.
- `f.seek(0)`: Go to start.
- `f.seek(0, 2)`: Go to end.
- `f.flush()`: Force write buffered data to disk.
- `f.readable()`: Check if file is readable.
- `f.writable()`: Check if file is writable.

## üì∏ Binary Files
- Use modes like `'rb'` or `'wb'`.
- Read/write raw bytes.
```python
# Reading binary file
with open('image.png', 'rb') as f:
    data = f.read()

# Writing binary file
with open('copy.png', 'wb') as f:
    f.write(data)
```

## üí° Practical Examples

### Counting Lines in a File
```python
with open('data.txt', 'r') as f:
    line_count = sum(1 for _ in f)
print(f"Total lines: {line_count}")
```

### Copying File Content
```python
with open('source.txt', 'r') as src, open('dest.txt', 'w') as dst:
    dst.write(src.read())
```

### Handling Large Files (Line by Line)
```python
with open('large_file.txt', 'r') as f:
    for line_num, line in enumerate(f, 1):
        if 'keyword' in line:
            print(f"Found at line {line_num}: {line.strip()}")
```

## üìä CSV Files with csv Module
- Use `csv` module for reading/writing CSV files properly.
- Handles quoting, escaping, and delimiters automatically.

### Reading CSV
```python
import csv

with open('data.csv', 'r') as f:
    reader = csv.reader(f)
    for row in reader:
        print(row)
```

### Writing CSV (csv.writer)
- Use `csv.writer` when writing data to CSV files.
- Ideal for: Writing rows of data, handling special characters (commas, quotes), custom delimiters, appending/creating files.
```python
import csv

data = [['Name', 'Age'], ['Alice', 30], ['Bob', 25]]

with open('output.csv', 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerows(data)  # Writes all rows
```

- `newline=''`: Prevents extra blank lines on Windows.
- For dict-based data, use `csv.DictWriter` for headers.

## ‚úÖ Best Practices
- **Always use `with`** for file handling to ensure closure.
- **Specify encoding** for text files: `open('file.txt', 'r', encoding='utf-8')`.
- **Handle exceptions**: Wrap in try-except for `FileNotFoundError`, `PermissionError`, etc.
- **Avoid reading large files entirely**: Use line-by-line processing.
- **Check file existence** before operations using `os.path.exists()` or `pathlib.Path.exists()`.
- **Use pathlib** for path handling instead of strings for better cross-platform support.