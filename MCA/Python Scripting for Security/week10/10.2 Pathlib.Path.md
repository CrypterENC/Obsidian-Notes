# Pathlib.Path in Python

## Overview
- `pathlib.Path` is an object-oriented way to handle file system paths in Python.
- Part of the `pathlib` module (Python 3.4+).
- Cross-platform and more intuitive than `os.path`.

## Importing and Creating Paths
```python
from pathlib import Path

# Create a Path object
p = Path('folder/file.txt')
home = Path.home()  # User's home directory
cwd = Path.cwd()    # Current working directory
```

## Common Methods

| Method                                 | What it returns                               | Example                                             |
| -------------------------------------- | --------------------------------------------- | --------------------------------------------------- |
| `p.exists()`                           | Boolean: True if path exists                  | `p.exists()` → True/False                           |
| `p.is_file()`                          | Boolean: True if path is a file               | `p.is_file()` → True/False                          |
| `p.is_dir()`                           | Boolean: True if path is a directory          | `p.is_dir()` → True/False                           |
| `p.parent`                             | Path object: Parent directory                 | `Path('a/b/c').parent` → Path('a/b')                |
| `p.name`                               | String: Final component (filename/dir)        | `Path('file.txt').name` → 'file.txt'                |
| `p.stem`                               | String: Filename without extension            | `Path('file.txt').stem` → 'file'                    |
| `p.suffix`                             | String: File extension                        | `Path('file.txt').suffix` → '.txt'                  |
| `p.resolve()`                          | Path object: Absolute path, symlinks resolved | `p.resolve()` → full absolute Path                  |
| `p.stat()`                             | Stat object: File/dir statistics              | `p.stat()` → os.stat_result                         |
| `p.chmod(mode)`                        | None: Changes permissions                     | `p.chmod(0o755)`                                    |
| `p.mkdir(parents=True, exist_ok=True)` | None: Creates directory                       | `p.mkdir(parents=True, exist_ok=True)`              |
| `p.rmdir()`                            | None: Removes empty directory                 | `p.rmdir()`                                         |
| `p.unlink()`                           | None: Deletes file                            | `p.unlink()`                                        |
| `p.rename(target)`                     | None: Renames file/directory                  | `p.rename('new_name')`                              |
| `p.read_text()`                        | String: File content as text                  | `p.read_text()` → 'file content'                    |
| `p.write_text(data)`                   | None: Writes text to file                     | `p.write_text('hello')`                             |
| `p.read_bytes()`                       | Bytes: File content as bytes                  | `p.read_bytes()` → b'content'                       |
| `p.write_bytes(data)`                  | None: Writes bytes to file                    | `p.write_bytes(b'hello')`                           |
| `p.glob(pattern)`                      | Generator of Path objects (non-recursive)     | `list(p.glob('*.txt'))` → [Path('file.txt')]        |
| `p.rglob(pattern)`                     | Generator of Path objects (recursive)         | `list(p.rglob('*.py'))` → [Path('sub/file.py')]     |
| `p.iterdir()`                          | Generator of Path objects in directory        | `list(p.iterdir())` → [Path('file1'), Path('dir1')] |

### Quick Comparison
| Method | What it returns | Example |
|--------|-----------------|---------|
| `os.listdir(p)` | Just names (as strings) | `['file1.txt', 'folder1']` |
| `p.iterdir()` | Full Path objects | `[Path('c:/folder/file1.txt'), Path('c:/folder/folder1')]` |
| `p.glob("*")` | Full Path objects (all items) | Same as iterdir() but with pattern |
| `p.glob("*.py")` | Full Path objects (filtered) | Only Python files |

## Operations
```python
# Joining paths
new_path = Path('folder') / 'subfolder' / 'file.txt'

# Reading/Writing
text = p.read_text()
p.write_text('Hello World')

# Creating directories
Path('new_folder').mkdir(parents=True, exist_ok=True)

# Deleting
p.unlink()  # Delete file
```

## Examples
```python
from pathlib import Path

# List all .txt files in current directory
txt_files = list(Path('.').glob('*.txt'))
print(txt_files)

# Check and create a directory
dir_path = Path('my_dir')
if not dir_path.exists():
    dir_path.mkdir()
```

### Basic Path Object Example
```python
from pathlib import Path

# Get current working directory
cwd = Path.cwd()
print(cwd)

# Create a new path using concatenation
# You can use cwd.joinpath or the special / symbol (overloaded for concatenation)
new_path = cwd / "some_folder" / "example.txt"

# Or using joinpath
# new_path = cwd.joinpath("some_folder", "example.txt")

print("New path:", new_path)

# Examine your new path object
# Print the following parts
print("Parent:", new_path.parent)  # .parent
print("Anchor:", new_path.anchor)  # .anchor
print("Name:", new_path.name)      # .name
print("Stem:", new_path.stem)      # .stem
print("Suffix:", new_path.suffix)  # .suffix

# Check if your path is a directory or file
print("Is file:", new_path.is_file())  # .is_file()
print("Is dir:", new_path.is_dir())    # .is_dir()

# Print out your path and look at the type
print("Path:", new_path)
print("Type:", type(new_path))
# Yes, it's a WindowsPath on Windows, reflecting the OS.
```

## Advantages
- Cleaner syntax than `os.path`.
- Path objects are immutable and hashable.
- Easy to use with modern Python features.