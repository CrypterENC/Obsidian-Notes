# Comprehensions in Python

Comprehensions provide a concise way to create new data structures from existing iterables. They are more readable and often faster than traditional loops.

## List Comprehensions

List comprehensions create lists.

### Syntax:
```python
[expression for item in iterable if condition]
```

### Examples:
```python
# Basic list comprehension
numbers = [x for x in range(1, 11)]
print(numbers)  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Squaring numbers
squares = [x**2 for x in range(1, 6)]
print(squares)  # [1, 4, 9, 16, 25]

# With condition
evens = [x for x in range(1, 11) if x % 2 == 0]
print(evens)  # [2, 4, 6, 8, 10]

# Applying a function
def double(x):
    return x * 2

doubles = [double(x) for x in range(1, 6)]
print(doubles)  # [2, 4, 6, 8, 10]
```

### When to Use List Comprehensions
List comprehensions are preferred over for-loops when you want compact code that is often easier to read. They condense simple loops into a single line, improving readability for straightforward transformations and filtering.

### Equivalent to For-Loop
```python
# For-loop equivalent
result = []
for x in range(1, 6):
    result.append(x**2)

# List comprehension
result = [x**2 for x in range(1, 6)]
```

## Set Comprehensions

Set comprehensions create sets (unordered, unique elements).

### Syntax:
```python
{expression for item in iterable if condition}
```

### Examples:
```python
# Basic set comprehension
numbers = {x for x in range(1, 11)}
print(numbers)  # {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

# Squaring unique numbers
squares = {x**2 for x in [1, 2, 2, 3, 3, 3]}
print(squares)  # {1, 4, 9}

# With condition
evens = {x for x in range(1, 11) if x % 2 == 0}
print(evens)  # {2, 4, 6, 8, 10}
```

## Dictionary Comprehensions

Dictionary comprehensions create dictionaries.

### Syntax:
```python
{key_expression: value_expression for item in iterable if condition}
```

### Examples:
```python
# Basic dictionary comprehension
squares = {x: x**2 for x in range(1, 6)}
print(squares)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# From two lists
keys = ['a', 'b', 'c']
values = [1, 2, 3]
my_dict = {keys[i]: values[i] for i in range(len(keys))}
print(my_dict)  # {'a': 1, 'b': 2, 'c': 3}

# With condition
evens = {x: x**2 for x in range(1, 11) if x % 2 == 0}
print(evens)  # {2: 4, 4: 16, 6: 36, 8: 64, 10: 100}

# Inverting a dictionary
original = {'a': 1, 'b': 2, 'c': 3}
inverted = {v: k for k, v in original.items()}
print(inverted)  # {1: 'a', 2: 'b', 3: 'c'}
```

## Tuple Comprehensions

There are no tuple comprehensions in Python. Instead, use generator expressions and convert to tuple.

### Syntax:
```python
tuple(expression for item in iterable if condition)
```

### Examples:
```python
# Basic tuple creation from generator
numbers = tuple(x for x in range(1, 6))
print(numbers)  # (1, 2, 3, 4, 5)

# Squaring with generator
squares = tuple(x**2 for x in range(1, 6))
print(squares)  # (1, 4, 9, 16, 25)

# With condition
evens = tuple(x for x in range(1, 11) if x % 2 == 0)
print(evens)  # (2, 4, 6, 8, 10)

# Note: Generator expressions use () but don't create tuple immediately
gen = (x**2 for x in range(1, 4))
print(type(gen))  # <class 'generator'>
print(tuple(gen))  # (1, 4, 9)
```